package com.ggp.utils.recall;

import com.ggp.*;
import com.ggp.games.RockPaperScissors.GameDescription;
import com.ggp.utils.exploitability.PerfectRecallExploitability;
import com.ggp.utils.strategy.Strategy;
import com.ggp.IInfoSetStrategy;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.MethodSource;
import sun.reflect.generics.reflectiveObjects.NotImplementedException;


import java.util.List;
import java.util.stream.IntStream;

import static org.junit.jupiter.api.Assertions.*;

class PerfectRecallExploitabilityTest {

    @ParameterizedTest
    @MethodSource("rpsSizes")
    void testRPS_uniform(int size) {
        // there is a numerical issue for some RPS sizes
        assertTrue(PerfectRecallExploitability.computeExploitability(new Strategy(), new GameDescription(size)) < 1e-16);
    }

    @ParameterizedTest
    @MethodSource("rpsSizes")
    void testRPS_singleAction(int size) {
        IStrategy singleAction = new IStrategy() {
            @Override
            public Iterable<IInformationSet> getDefinedInformationSets() {
                throw new NotImplementedException();
            }

            @Override
            public boolean isDefined(IInformationSet is) {
                return true;
            }

            @Override
            public IInfoSetStrategy getInfoSetStrategy(IInformationSet is) {
                return new IInfoSetStrategy() {
                    @Override
                    public double getProbability(int actionIdx) {
                        if (actionIdx == 0) return 1;
                        return 0;
                    }

                    @Override
                    public int size() {
                        return 0;
                    }
                };
            }
        };
        ICompleteInformationState initialState = new GameDescription(size).getInitialState();
        assertEquals(1d, PerfectRecallExploitability.computeExploitability(singleAction, initialState));
        Strategy bestResponse = new Strategy();
        assertEquals(1d, PerfectRecallExploitability.computeExploitability(singleAction, initialState, bestResponse));

        // first action that beats 1 is chosen since all that beat it have the same value.
        IInfoSetStrategy isStrat = bestResponse.getInfoSetStrategy(initialState.getInfoSetForActingPlayer());
        assertEquals(1d, isStrat.getProbability(1 + (size - 1)/2));
    }

    static IntStream rpsSizes() {
        return IntStream.of(3, 5, 7, 9, 11, 29);
    }

    @Test
    void testTerminal() {
        assertEquals(0d, PerfectRecallExploitability.computeExploitability(new Strategy(), new ICompleteInformationState() {
            @Override
            public boolean isTerminal() {
                return true;
            }

            @Override
            public int getActingPlayerId() {
                return 0;
            }

            @Override
            public double getPayoff(int player) {
                if (player == 1) return 1;
                return -1;
            }

            @Override
            public List<IAction> getLegalActions() {
                return null;
            }

            @Override
            public IInformationSet getInfoSetForPlayer(int player) {
                return null;
            }

            @Override
            public ICompleteInformationState next(IAction a) {
                return null;
            }

            @Override
            public Iterable<IPercept> getPercepts(IAction a) {
                return null;
            }

            @Override
            public IRandomNode getRandomNode() {
                return null;
            }
        }));
    }
}