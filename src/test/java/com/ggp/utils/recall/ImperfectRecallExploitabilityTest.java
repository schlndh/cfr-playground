package com.ggp.utils.recall;

import com.ggp.*;
import com.ggp.games.LeducPoker.GameDescription;
import com.ggp.games.LeducPoker.InformationSet;
import com.ggp.games.LeducPoker.Rounds;
import com.ggp.games.LeducPoker.actions.CallAction;
import com.ggp.games.LeducPoker.actions.FoldAction;
import com.ggp.games.LeducPoker.actions.RaiseAction;
import com.ggp.utils.strategy.Strategy;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.MethodSource;
import sun.reflect.generics.reflectiveObjects.NotImplementedException;

import java.util.stream.IntStream;

import static org.junit.jupiter.api.Assertions.*;

class ImperfectRecallExploitabilityTest {
    @Test
    void testLeduc_alwaysFold() {
        ICompleteInformationState initialState = new GameDescription(7).getInitialState();
        IStrategy alwaysFold = new IStrategy() {
            @Override
            public Iterable<IInformationSet> getDefinedInformationSets() {
                throw new NotImplementedException();
            }

            @Override
            public boolean isDefined(IInformationSet is) {
                return true;
            }

            @Override
            public IInfoSetStrategy getInfoSetStrategy(IInformationSet is) {
                return new IInfoSetStrategy() {
                    @Override
                    public double getProbability(int actionIdx) {
                        if (is.getLegalActions().get(actionIdx).getClass() == FoldAction.class) return 1;
                        return 0;
                    }

                    @Override
                    public int size() {
                        return is.getLegalActions().size();
                    }
                };
            }
        };

        // always fold strategy will lose 1 chip per game (initial bet)
        assertEquals(1, ImperfectRecallExploitability.computeExploitability(alwaysFold, initialState));
    }

    @Test
    void testLeduc_raiseThenFold() {
        ICompleteInformationState initialState = new GameDescription(7).getInitialState();
        IStrategy alwaysFold = new IStrategy() {
            @Override
            public Iterable<IInformationSet> getDefinedInformationSets() {
                throw new NotImplementedException();
            }

            @Override
            public boolean isDefined(IInformationSet is) {
                return true;
            }

            @Override
            public IInfoSetStrategy getInfoSetStrategy(IInformationSet iis) {
                return new IInfoSetStrategy() {
                    @Override
                    public double getProbability(int actionIdx) {
                        InformationSet is = (InformationSet) iis;
                        IAction a = is.getLegalActions().get(actionIdx);
                        if (is.getRound() == Rounds.Bet2) {
                            if (a.getClass() == FoldAction.class) return 1;
                        } else {
                            if (is.wasRaised() && a.getClass() == CallAction.class) return 1;
                            if (!is.wasRaised() && a.getClass() == RaiseAction.class) return 1;
                        }
                        return 0;
                    }

                    @Override
                    public int size() {
                        return iis.getLegalActions().size();
                    }
                };
            }
        };

        // always fold strategy will lose 3 chips
        assertEquals(3, ImperfectRecallExploitability.computeExploitability(alwaysFold, initialState));
    }

    @ParameterizedTest
    @MethodSource("rpsSizes")
    void testRPS_uniform(int size) {
        // there is a numerical issue for some RPS sizes
        assertTrue(ImperfectRecallExploitability.computeExploitability(new Strategy(), new com.ggp.games.RockPaperScissors.GameDescription(size)) < 1e-16);
    }

    @ParameterizedTest
    @MethodSource("rpsSizes")
    void testRPS_singleAction(int size) {
        IStrategy singleAction = new IStrategy() {
            @Override
            public Iterable<IInformationSet> getDefinedInformationSets() {
                throw new NotImplementedException();
            }

            @Override
            public boolean isDefined(IInformationSet is) {
                return true;
            }

            @Override
            public IInfoSetStrategy getInfoSetStrategy(IInformationSet is) {
                return new IInfoSetStrategy() {
                    @Override
                    public double getProbability(int actionIdx) {
                        if (actionIdx == 0) return 1;
                        return 0;
                    }

                    @Override
                    public int size() {
                        return is.getLegalActions().size();
                    }
                };
            }
        };
        assertEquals(1d, ImperfectRecallExploitability.computeExploitability(singleAction, new com.ggp.games.RockPaperScissors.GameDescription(size)));
    }

    static IntStream rpsSizes() {
        return IntStream.of(3, 5, 7, 9, 11, 29);
    }

}